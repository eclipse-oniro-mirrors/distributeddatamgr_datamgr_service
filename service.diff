diff --git a/services/distributeddataservice/service/udmf/udmf_service_impl.cpp b/services/distributeddataservice/service/udmf/udmf_service_impl.cpp
index b40334046..867631d2e 100755
--- a/services/distributeddataservice/service/udmf/udmf_service_impl.cpp
+++ b/services/distributeddataservice/service/udmf/udmf_service_impl.cpp
@@ -27,6 +27,7 @@
 #include "bundlemgr/bundle_mgr_proxy.h"
 #include "checker/checker_manager.h"
 #include "checker_manager.h"
+#include "delay_data_container.h"
 #include "device_manager_adapter.h"
 #include "device_matrix.h"
 #include "iservice_registry.h"
@@ -37,6 +38,7 @@
 #include "metadata/meta_data_manager.h"
 #include "preprocess_utils.h"
 #include "dfx/reporter.h"
+#include "store_data_changed_observer.h"
 #include "system_ability_definition.h"
 #include "uri_permission_manager.h"
 #include "udmf_radar_reporter.h"
@@ -66,7 +68,7 @@ constexpr const char *DEVICE_PHONE_TAG = "phone";
 constexpr const char *DEVICE_DEFAULT_TAG = "default";
 constexpr const char *HAP_LIST[] = {"com.ohos.pasteboarddialog"};
 constexpr uint32_t FOUNDATION_UID = 5523;
-constexpr uint32_t WAIT_TIME = 800;
+constexpr const char *UD_KEY_ACCEPTABLE_INFO_SEPARATOR = "#acceptableInfo";
 __attribute__((used)) UdmfServiceImpl::Factory UdmfServiceImpl::factory_;
 UdmfServiceImpl::Factory::Factory()
 {
@@ -84,6 +86,16 @@ UdmfServiceImpl::Factory::~Factory()
     product_ = nullptr;
 }
 
+std::shared_ptr<UdmfServiceImpl> UdmfServiceImpl::Factory::GetProduct()
+{
+    return product_;
+}
+
+std::shared_ptr<UdmfServiceImpl> UdmfServiceImpl::GetService()
+{
+    return UdmfServiceImpl::factory_.GetProduct();
+}
+
 UdmfServiceImpl::UdmfServiceImpl()
 {
     CheckerManager::GetInstance().LoadCheckers();
@@ -181,7 +193,7 @@ int32_t UdmfServiceImpl::GetData(const QueryOption &query, UnifiedData &unifiedD
     }
     msg.appId = bundleName;
 
-    bool handledByDelay = HandleDelayLoad(query, unifiedData, res);
+    bool handledByDelay = DelayDataContainer::GetInstance().HandleDelayLoad(query, unifiedData, res);
     if (!handledByDelay) {
         res = RetrieveData(query, unifiedData);
     }
@@ -201,34 +213,10 @@ int32_t UdmfServiceImpl::GetData(const QueryOption &query, UnifiedData &unifiedD
     return res;
 }
 
-bool UdmfServiceImpl::HandleDelayLoad(const QueryOption &query, UnifiedData &unifiedData, int32_t &res)
-{
-    return dataLoadCallback_.ComputeIfPresent(query.key, [&](const auto &key, auto &callback) {
-        std::shared_ptr<BlockData<std::optional<UnifiedData>, std::chrono::milliseconds>> blockData;
-        auto [found, cache] = blockDelayDataCache_.Find(key);
-        if (found) {
-            blockData = cache.blockData;
-        } else {
-            blockData = std::make_shared<BlockData<std::optional<UnifiedData>, std::chrono::milliseconds>>(WAIT_TIME);
-            blockDelayDataCache_.Insert(key, BlockDelayData{query.tokenId, blockData});
-            callback->HandleDelayObserver(key, DataLoadInfo());
-        }
-        ZLOGI("Start waiting for data, key:%{public}s", key.c_str());
-        auto dataOpt = blockData->GetValue();
-        if (dataOpt.has_value()) {
-            unifiedData = *dataOpt;
-            blockDelayDataCache_.Erase(key);
-            return false;
-        }
-        res = E_NOT_FOUND;
-        return true;
-    });
-}
-
-bool UdmfServiceImpl::CheckDragParams(UnifiedKey &key, const QueryOption &query)
+bool UdmfServiceImpl::CheckDragParams(UnifiedKey &key)
 {
     if (!key.IsValid()) {
-        ZLOGE("Unified key: %{public}s is invalid.", query.key.c_str());
+        ZLOGE("Unified key: %{public}s is invalid.", key.GetUnifiedKey().c_str());
         return false;
     }
     if (key.intention != UD_INTENTION_MAP.at(UD_INTENTION_DRAG)) {
@@ -241,10 +229,10 @@ bool UdmfServiceImpl::CheckDragParams(UnifiedKey &key, const QueryOption &query)
 int32_t UdmfServiceImpl::RetrieveData(const QueryOption &query, UnifiedData &unifiedData)
 {
     UnifiedKey key(query.key);
-    if (!CheckDragParams(key, query)) {
+    if (!CheckDragParams(key)) {
         return E_INVALID_PARAMETERS;
     }
-    auto store = StoreCache::GetInstance().GetStore(key.intention);
+    auto store = StoreCache::GetInstance().GetStore(UD_INTENTION_MAP.at(UD_INTENTION_DRAG));
     if (store == nullptr) {
         ZLOGE("Get store failed:%{public}s", key.intention.c_str());
         return E_DB_ERROR;
@@ -252,7 +240,7 @@ int32_t UdmfServiceImpl::RetrieveData(const QueryOption &query, UnifiedData &uni
     int32_t res = store->Get(query.key, unifiedData);
     if (res != E_OK) {
         ZLOGE("Get data failed,res:%{public}d,key:%{public}s", res, query.key.c_str());
-        HandleDbError(key.intention, res);
+        HandleDbError(UD_INTENTION_MAP.at(UD_INTENTION_DRAG), res);
         return res;
     }
 
@@ -270,7 +258,7 @@ int32_t UdmfServiceImpl::RetrieveData(const QueryOption &query, UnifiedData &uni
         return res;
     }
     if (!IsReadAndKeep(runtime->privileges, query) && LifeCycleManager::GetInstance().OnGot(key) != E_OK) {
-        ZLOGE("Remove data failed:%{public}s", key.intention.c_str());
+        ZLOGE("Remove data failed");
         return E_DB_ERROR;
     }
     int32_t ret = ProcessUri(query, unifiedData);
@@ -629,7 +617,7 @@ int32_t UdmfServiceImpl::AddPrivilege(const QueryOption &query, Privilege &privi
 
     Runtime runtime;
     int32_t res = store->GetRuntime(query.key, runtime);
-    if (res == E_NOT_FOUND) {
+    if (res == E_NOT_FOUND || runtime.dataStatus == DataStatus::DELAY) {
         std::lock_guard<std::recursive_mutex> lock(cacheMutex_);
         privilegeCache_[query.key] = privilege;
         ZLOGW("Add privilege in cache, key: %{public}s.", query.key.c_str());
@@ -929,15 +917,21 @@ int32_t UdmfServiceImpl::ObtainAsynProcess(AsyncProcessInfo &processInfo)
         return E_INVALID_PARAMETERS;
     }
     std::lock_guard<std::mutex> lock(mutex_);
+    processInfo.syncStatus = AsyncTaskStatus::ASYNC_SUCCESS;
+    processInfo.srcDevName = "Local";
     if (asyncProcessInfoMap_.empty()) {
-        processInfo.syncStatus = AsyncTaskStatus::ASYNC_SUCCESS;
-        processInfo.srcDevName = "Local";
+        if (!IsSyncFinished(processInfo.businessUdKey)) {
+            processInfo.syncStatus = AsyncTaskStatus::ASYNC_RUNNING;
+            processInfo.srcDevName = "Remote";
+        }
         return E_OK;
     }
     auto it = asyncProcessInfoMap_.find(processInfo.businessUdKey);
     if (it == asyncProcessInfoMap_.end()) {
-        processInfo.syncStatus = AsyncTaskStatus::ASYNC_SUCCESS;
-        processInfo.srcDevName = "Local";
+        if (!IsSyncFinished(processInfo.businessUdKey)) {
+            processInfo.syncStatus = AsyncTaskStatus::ASYNC_RUNNING;
+            processInfo.srcDevName = "Remote";
+        }
         return E_OK;
     }
     auto asyncProcessInfo = asyncProcessInfoMap_.at(processInfo.businessUdKey);
@@ -1180,59 +1174,84 @@ bool UdmfServiceImpl::IsValidOptionsNonDrag(UnifiedKey &key, const std::string &
 int32_t UdmfServiceImpl::SetDelayInfo(const DataLoadInfo &dataLoadInfo, sptr<IRemoteObject> iUdmfNotifier,
     std::string &key)
 {
-    std::string bundleName;
-    std::string specificBundleName;
-    auto tokenId = static_cast<uint32_t>(IPCSkeleton::GetCallingTokenID());
-    if (!PreProcessUtils::GetSpecificBundleNameByTokenId(tokenId, specificBundleName, bundleName)) {
-        ZLOGE("GetSpecificBundleNameByTokenId failed, tokenid:%{public}u", tokenId);
+    UnifiedData delayData;
+    CustomOption option = {
+        .intention = UD_INTENTION_DRAG,
+        .tokenId = static_cast<uint32_t>(IPCSkeleton::GetCallingTokenID())
+    };
+    if (PreProcessUtils::FillDelayRuntimeInfo(delayData, option, dataLoadInfo) != E_OK) {
+        ZLOGE("FillDelayRuntimeInfo failed!");
         return E_ERROR;
     }
-    UnifiedKey udkey(UD_INTENTION_MAP.at(UD_INTENTION_DRAG), specificBundleName, dataLoadInfo.sequenceKey);
-    key = udkey.GetUnifiedKey();
-    dataLoadCallback_.Insert(key, iface_cast<UdmfNotifierProxy>(iUdmfNotifier));
-
+    auto runtime = delayData.GetRuntime();
+    if (runtime == nullptr) {
+        ZLOGE("Get runtime failed!");
+        return E_ERROR;
+    }
+    key = runtime->key.GetUnifiedKey();
+    DelayDataContainer::GetInstance().RegisterDataLoadCallback(key, iface_cast<UdmfNotifierProxy>(iUdmfNotifier));
     auto store = StoreCache::GetInstance().GetStore(UD_INTENTION_MAP.at(UD_INTENTION_DRAG));
     if (store == nullptr) {
         ZLOGE("Get store failed:%{public}s", key.c_str());
         return E_DB_ERROR;
     }
-
     Summary summary;
     UnifiedDataHelper::GetSummaryFromLoadInfo(dataLoadInfo, summary);
-    int32_t status = store->PutSummary(udkey, summary);
+    int32_t status = store->PutSummary(runtime->key, summary);
     if (status != E_OK) {
         ZLOGE("Put summary failed:%{public}s, status:%{public}d", key.c_str(), status);
         HandleDbError(UD_INTENTION_MAP.at(UD_INTENTION_DRAG), status);
         return E_DB_ERROR;
     }
+    status = store->PutDelayData(delayData);
+    if (status != E_OK) {
+        ZLOGE("Put delay data failed:%{public}s, status:%{public}d", key.c_str(), status);
+        HandleDbError(UD_INTENTION_MAP.at(UD_INTENTION_DRAG), status);
+        return E_DB_ERROR;
+    }
+    RegisterObserver(key);
     return E_OK;
 }
 
 int32_t UdmfServiceImpl::PushDelayData(const std::string &key, UnifiedData &unifiedData)
 {
-    auto delayIt = delayDataCallback_.Find(key);
-    auto blockIt = blockDelayDataCache_.Find(key);
-    bool isDataLoading = (delayIt.first);
-    if (!isDataLoading && !blockIt.first) {
-        ZLOGE("DelayData callback and block cache not exist, key:%{public}s", key.c_str());
-        return E_ERROR;
+    UnifiedKey udKey(key);
+    if (!CheckDragParams(udKey)) {
+        return E_INVALID_PARAMETERS;
     }
+    std::string observerKey = key + UD_KEY_ACCEPTABLE_INFO_SEPARATOR;
+    UnRegisterObserver(observerKey);
+    DelayGetDataInfo getDataInfo;
+    BlockDelayData blockData;
+    auto isDataLoading = DelayDataContainer::GetInstance().QueryDelayGetDataInfo(key, getDataInfo);
+    auto isBlockData = DelayDataContainer::GetInstance().QueryBlockDelayData(key, blockData);
 
-    CustomOption option;
-    option.intention = UD_INTENTION_DRAG;
-    option.tokenId = static_cast<uint32_t>(IPCSkeleton::GetCallingTokenID());
+    CustomOption option = {
+        .intention = UD_INTENTION_DRAG,
+        .tokenId = static_cast<uint32_t>(IPCSkeleton::GetCallingTokenID())
+    };
     if (PreProcessUtils::FillRuntimeInfo(unifiedData, option) != E_OK) {
-        ZLOGE("Imputation failed");
+        ZLOGE("Fill runtime info failed");
         return E_ERROR;
     }
+    auto runtime = unifiedData.GetRuntime();
+    if (runtime == nullptr) {
+        return E_ERROR;
+    }
+    runtime->key = udKey;
+    PreProcessUtils::SetRecordUid(unifiedData);
     int32_t ret = PreProcessUtils::HandleFileUris(option.tokenId, unifiedData);
     if (ret != E_OK) {
         ZLOGE("HandleFileUris failed, ret:%{public}d, key:%{public}s.", ret, key.c_str());
         return ret;
     }
-
+    
+    if (!isDataLoading && !isBlockData) {
+        ZLOGW("DelayData callback and block cache not exist, key:%{public}s", key.c_str());
+        return UpdateDelayData(key, unifiedData);
+    }
     QueryOption query;
-    query.tokenId = isDataLoading ? delayIt.second.tokenId : blockIt.second.tokenId;
+    query.tokenId = isDataLoading ? getDataInfo.tokenId : blockData.tokenId;
     query.key = key;
     if (option.tokenId != query.tokenId && !IsPermissionInCache(query)) {
         ZLOGE("No permission");
@@ -1251,31 +1270,62 @@ int32_t UdmfServiceImpl::PushDelayData(const std::string &key, UnifiedData &unif
     TransferToEntriesIfNeed(query, unifiedData);
 
     if (isDataLoading) {
-        return HandleDelayDataCallback(delayIt.second, unifiedData, key);
+        return DelayDataContainer::GetInstance().HandleDelayDataCallback(key, unifiedData) ? E_OK : E_ERROR;
     }
-    blockIt.second.blockData->SetValue(unifiedData);
+    blockData.blockData->SetValue(unifiedData);
     return E_OK;
 }
 
-int32_t UdmfServiceImpl::HandleDelayDataCallback(DelayGetDataInfo &delayGetDataInfo, UnifiedData &unifiedData,
-    const std::string &key)
+int32_t UdmfServiceImpl::UpdateDelayData(const std::string &key, UnifiedData &unifiedData)
 {
-    auto callback = iface_cast<DelayDataCallbackProxy>(delayGetDataInfo.dataCallback);
-    if (callback == nullptr) {
-        ZLOGE("Delay data callback is null, key:%{public}s", key.c_str());
+    UnifiedKey udKey(key);
+    if (!CheckDragParams(udKey)) {
+        return E_INVALID_PARAMETERS;
+    }
+    auto store = StoreCache::GetInstance().GetStore(udKey.intention);
+    if (store == nullptr) {
+        ZLOGE("Get store failed:%{public}s", udKey.intention.c_str());
+        return E_DB_ERROR;
+    }
+    uint32_t tokenId = static_cast<uint32_t>(IPCSkeleton::GetCallingTokenID());
+    ZLOGE("Unified data update :%{public}s", key.c_str());
+    int32_t res = store->Update(unifiedData);
+    if (res != E_OK) {
+        ZLOGE("Unified data update failed:%{public}s", key.c_str());
+        HandleDbError(UD_INTENTION_MAP.at(UD_INTENTION_DRAG), res);
+        return E_DB_ERROR;
+    }
+    QueryOption queryOption = {
+        .key = key,
+        .intention = UD_INTENTION_DRAG,
+        .tokenId = tokenId
+    };
+    std::vector<std::string> devices;
+    DataLoadInfo info;
+    if (DelayDataContainer::GetInstance().QueryDelayAcceptableInfo(key, info)) {
+        ZLOGI("Find from acceptable info notify.");
+        devices.push_back(info.deviceId);
+    } else {
+        ZLOGI("Find from remote sync notify.");
+        devices = DelayDataContainer::GetInstance().QueryDelayDragDeviceInfo();
+    }
+    if (devices.empty()) {
+        ZLOGE("Remote devices empty.");
         return E_ERROR;
     }
-    callback->DelayDataCallback(key, unifiedData);
-    delayDataCallback_.Erase(key);
+    // clear saved deviceId list when every push operation.
+    DelayDataContainer::GetInstance().ClearDelayDragDeviceInfo();
+    PushDelayDataToRemote(queryOption, devices);
     return E_OK;
 }
 
 int32_t UdmfServiceImpl::GetDataIfAvailable(const std::string &key, const DataLoadInfo &dataLoadInfo,
     sptr<IRemoteObject> iUdmfNotifier, std::shared_ptr<UnifiedData> unifiedData)
 {
-    ZLOGD("start");
+    ZLOGE("start");
     QueryOption query;
-    query.tokenId = static_cast<uint32_t>(IPCSkeleton::GetCallingTokenID());
+    uint32_t tokenId = static_cast<uint32_t>(IPCSkeleton::GetCallingTokenID());
+    query.tokenId = tokenId;
     query.key = key;
     if (unifiedData == nullptr) {
         ZLOGE("Data is null, key:%{public}s", key.c_str());
@@ -1283,6 +1333,7 @@ int32_t UdmfServiceImpl::GetDataIfAvailable(const std::string &key, const DataLo
     }
     auto status = RetrieveData(query, *unifiedData);
     if (status == E_OK) {
+        UnRegisterObserver(key); // Unregister observer when unified data ready.
         return E_OK;
     }
     if (status != E_NOT_FOUND) {
@@ -1291,16 +1342,18 @@ int32_t UdmfServiceImpl::GetDataIfAvailable(const std::string &key, const DataLo
     }
     DelayGetDataInfo delayGetDataInfo;
     delayGetDataInfo.dataCallback = iUdmfNotifier;
-    delayGetDataInfo.tokenId = static_cast<uint32_t>(IPCSkeleton::GetCallingTokenID());
-    delayDataCallback_.InsertOrAssign(key, std::move(delayGetDataInfo));
+    delayGetDataInfo.tokenId = tokenId;
+    DelayDataContainer::GetInstance().RegisterDelayDataCallback(key, std::move(delayGetDataInfo));
 
-    auto it = dataLoadCallback_.Find(key);
-    if (!it.first) {
-        ZLOGE("DataLoad callback no exist, key:%{public}s", key.c_str());
+    if (!DelayDataContainer::GetInstance().ExecDataLoadCallback(key, dataLoadInfo)) {
+        auto runtime = unifiedData->GetRuntime();
+        std::string localDeviceId = PreProcessUtils::GetLocalDeviceId();
+        if (runtime != nullptr && runtime->deviceId != localDeviceId) {
+            ZLOGE("Wait delay data from another device, key: %{public}s", key.c_str());
+            return E_OK;
+        }
         return E_ERROR;
     }
-    it.second->HandleDelayObserver(key, dataLoadInfo);
-    dataLoadCallback_.Erase(key);
     return E_OK;
 }
 
@@ -1357,5 +1410,171 @@ std::vector<std::string> UdmfServiceImpl::ProcessResult(const std::map<std::stri
     ZLOGI("Meta sync finish, total size:%{public}zu, success size:%{public}zu", results.size(), devices.size());
     return devices;
 }
+
+void UdmfServiceImpl::RegisterObserver(const std::string &key)
+{
+    auto store = StoreCache::GetInstance().GetStore(UD_INTENTION_MAP.at(UD_INTENTION_DRAG));
+    if (store == nullptr) {
+        ZLOGE("Get store failed:%{public}s", key.c_str());
+        return;
+    }
+    // register notifier
+    store->SetRemotePullStartNotify();
+
+    // register acceptable info observer
+    std::string acceptableInfoKey = key + UD_KEY_ACCEPTABLE_INFO_SEPARATOR;
+    store->RegisterDataChangedObserver(acceptableInfoKey, ObserverFac::ObserverType::ACCEPTABLE_INFO);
+}
+
+void UdmfServiceImpl::UnRegisterObserver(const std::string &key)
+{
+    auto store = StoreCache::GetInstance().GetStore(UD_INTENTION_MAP.at(UD_INTENTION_DRAG));
+    if (store == nullptr) {
+        ZLOGE("Get store failed:%{public}s", key.c_str());
+        return;
+    }
+    store->UnRegisterDataChangedObserver(key);
+}
+
+bool UdmfServiceImpl::IsSyncFinished(const std::string &key)
+{
+    auto store = StoreCache::GetInstance().GetStore(UD_INTENTION_MAP.at(UD_INTENTION_DRAG));
+    if (store == nullptr) {
+        ZLOGE("Get store failed:%{public}s", key.c_str());
+        return E_DB_ERROR;
+    }
+    UnifiedData unifiedData;
+    int32_t res = store->Get(key, unifiedData);
+    if (res != E_OK) {
+        ZLOGE("Get data failed, res:%{public}d, key:%{public}s", res, key.c_str());
+        HandleDbError(UD_INTENTION_MAP.at(UD_INTENTION_DRAG), res);
+        return false;
+    }
+    auto runtime = unifiedData.GetRuntime();
+    if (runtime == nullptr) {
+        ZLOGE("Runtime is empty, key: %{public}s", key.c_str());
+        return false;
+    }
+    return true;
+}
+
+int32_t UdmfServiceImpl::SaveAcceptableInfo(const std::string &key, DataLoadInfo &info)
+{
+    UnifiedKey udKey(key);
+    if (!CheckDragParams(udKey)) {
+        return E_INVALID_PARAMETERS;
+    }
+    auto store = StoreCache::GetInstance().GetStore(UD_INTENTION_MAP.at(UD_INTENTION_DRAG));
+    if (store == nullptr) {
+        ZLOGE("Get store failed:%{public}s", key.c_str());
+        return E_DB_ERROR;
+    }
+    info.deviceId = PreProcessUtils::GetRealLocalDeviceId();
+    info.sequenceKey = key;
+    int32_t status = store->PutDataLoadInfo(info);
+    if (status != E_OK) {
+        ZLOGE("Put data load info failed, status:%{public}d, key:%{public}s", status, key.c_str());
+        HandleDbError(UD_INTENTION_MAP.at(UD_INTENTION_DRAG), status);
+        return E_DB_ERROR;
+    }
+    return E_OK;
+}
+
+int32_t UdmfServiceImpl::PushAcceptableInfo(const QueryOption &query, const std::vector<std::string> &devices)
+{
+    if (!UTILS::IsTokenNative(query.tokenId) ||
+        !DistributedKv::PermissionValidator::GetInstance().CheckSyncPermission(query.tokenId)) {
+        ZLOGE("Tokenid permission verification failed!");
+        return E_NO_PERMISSION;
+    }
+    auto store = StoreCache::GetInstance().GetStore(UD_INTENTION_MAP.at(UD_INTENTION_DRAG));
+    if (store == nullptr) {
+        ZLOGE("Get store failed:%{public}s", query.key.c_str());
+        return E_DB_ERROR;
+    }
+    // Watch unified data from another device.
+    store->RegisterDataChangedObserver(query.key, ObserverFac::ObserverType::RUNTIME);
+    return PushDelayDataToRemote(query, devices);
+    
+}
+
+int32_t UdmfServiceImpl::PushDelayDataToRemote(const QueryOption &query, const std::vector<std::string> &devices)
+{
+    if (devices.empty()) {
+        return E_OK;
+    }
+    UnifiedKey key(query.key);
+    if (!CheckDragParams(key)) {
+        return E_INVALID_PARAMETERS;
+    }
+    auto store = StoreCache::GetInstance().GetStore(UD_INTENTION_MAP.at(UD_INTENTION_DRAG));
+    if (store == nullptr) {
+        ZLOGE("Get store failed:%{public}s", query.key.c_str());
+        return E_DB_ERROR;
+    }
+    auto callback = [this, query](AsyncProcessInfo &syncInfo) {
+        if (query.key.empty()) {
+            return;
+        }
+        syncInfo.businessUdKey = query.key;
+    };
+    int userId = 0;
+    if (!AccountDelegate::GetInstance()->QueryForegroundUserId(userId)) {
+        ZLOGE("QueryForegroundUserId failed");
+        return E_ERROR;
+    }
+    auto meta = BuildMeta(UD_INTENTION_MAP.at(UD_INTENTION_DRAG), userId);
+    auto uuids = DmAdapter::GetInstance().ToUUID(devices);
+    if (IsNeedMetaSync(meta, uuids)) {
+        bool res = MetaDataManager::GetInstance().Sync(uuids, [this, devices, callback, store] (auto &results) {
+            auto successRes = ProcessResult(results);
+            if (store->PushDelayData(successRes, callback) != E_OK) {
+                ZLOGE("Store sync failed");
+            }
+        });
+        if (!res) {
+            ZLOGE("Meta sync failed");
+            RadarReporterAdapter::ReportFail(std::string(__FUNCTION__),
+                BizScene::SYNC_DATA, SyncDataStage::SYNC_END, StageRes::FAILED, E_DB_ERROR, BizState::DFX_END);
+            return E_DB_ERROR;
+        }
+        return E_OK;
+    }
+    if (store->PushDelayData(devices, callback) != E_OK) {
+        ZLOGE("Store sync failed");
+        return UDMF::E_DB_ERROR;
+    }
+    return E_OK;
+}
+
+int32_t UdmfServiceImpl::HandleRemoteDelayData(const std::string key)
+{
+    ZLOGI("HandleRemoteDelayData start");
+    UnRegisterObserver(key); // Unregister observer when unified data ready.
+    DelayGetDataInfo getDataInfo;
+    BlockDelayData blockData;
+    auto isDataLoading = DelayDataContainer::GetInstance().QueryDelayGetDataInfo(key, getDataInfo);
+    auto isBlockData = DelayDataContainer::GetInstance().QueryBlockDelayData(key, blockData);
+
+    if (!isDataLoading && !isBlockData) {
+        ZLOGE("DelayData callback and block cache not exist key: %{public}s", key.c_str());
+        return E_ERROR;
+    }
+    UnifiedData unifiedData;
+    QueryOption query = {
+        .key = key,
+        .tokenId = isDataLoading ? getDataInfo.tokenId : blockData.tokenId
+    };
+    auto status = RetrieveData(query, unifiedData);
+    if (status != E_OK) {
+        ZLOGI("query data fail, status:%{public}d", status);
+        return status;
+    }
+    if (isDataLoading) {
+        return DelayDataContainer::GetInstance().HandleDelayDataCallback(key, unifiedData) ? E_OK : E_ERROR;
+    }
+    blockData.blockData->SetValue(unifiedData);
+    return E_OK;
+}
 } // namespace UDMF
 } // namespace OHOS
\ No newline at end of file